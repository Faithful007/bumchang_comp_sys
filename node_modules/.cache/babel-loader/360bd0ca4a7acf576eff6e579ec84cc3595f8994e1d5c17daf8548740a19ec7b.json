{"ast":null,"code":"// src/modules/designConditions/calculations.js\n\n// Design-speed-based capacity (per lane, veh/h or pcu/h) – you can tune these.\nexport const SPEED_CAPACITY_TABLE = {\n  80: 2000,\n  100: 2200,\n  120: 2300\n};\n\n// Service level code mapping A-F -> 1-6\nconst SERVICE_LEVEL_MAP = {\n  A: 1,\n  B: 2,\n  C: 3,\n  D: 4,\n  E: 5,\n  F: 6\n};\nexport function serviceLevelCodeToNumber(code) {\n  return SERVICE_LEVEL_MAP[code] || null;\n}\n\n/**\r\n * Compute basic stats for one direction from its segments.\r\n * segments: array of { slopePercent, lengthM, avgElevationM, laneCount }\r\n */\nexport function computeDirectionStats(segments) {\n  const totalLengthM = segments.reduce((sum, seg) => sum + (Number(seg.lengthM) || 0), 0);\n\n  // Max lanes among segments in that direction\n  const lanes = segments.reduce((max, seg) => Math.max(max, Number(seg.laneCount) || 0), 0) || 0;\n  return {\n    totalLengthM,\n    lanes\n  };\n}\n\n/**\r\n * Estimate traffic volume for one direction.\r\n *\r\n * designSpeedKmH: 80 / 100 / 120 ...\r\n * capacityUsageRatio: 0.3 / 0.2 / 0.1 ...\r\n * lanes: number of lanes in this direction\r\n *\r\n * Returns { baseCapacityPerLane, capacityTotal, estimatedVolume }.\r\n */\nexport function estimateTrafficVolume({\n  designSpeedKmH,\n  capacityUsageRatio,\n  lanes\n}) {\n  var _SPEED_CAPACITY_TABLE;\n  const speed = Number(designSpeedKmH);\n  const ratio = Number(capacityUsageRatio);\n  const baseCapacityPerLane = (_SPEED_CAPACITY_TABLE = SPEED_CAPACITY_TABLE[speed]) !== null && _SPEED_CAPACITY_TABLE !== void 0 ? _SPEED_CAPACITY_TABLE : SPEED_CAPACITY_TABLE[80];\n  const capacityTotal = baseCapacityPerLane * (lanes || 0);\n  const estimatedVolume = Math.round(capacityTotal * (ratio || 0));\n  return {\n    baseCapacityPerLane,\n    capacityTotal,\n    estimatedVolume\n  };\n}","map":{"version":3,"names":["SPEED_CAPACITY_TABLE","SERVICE_LEVEL_MAP","A","B","C","D","E","F","serviceLevelCodeToNumber","code","computeDirectionStats","segments","totalLengthM","reduce","sum","seg","Number","lengthM","lanes","max","Math","laneCount","estimateTrafficVolume","designSpeedKmH","capacityUsageRatio","_SPEED_CAPACITY_TABLE","speed","ratio","baseCapacityPerLane","capacityTotal","estimatedVolume","round"],"sources":["C:/Users/USER/sourcecodes/auto-excel/comp-engine2/src/modules/designConditions/calculations.js"],"sourcesContent":["// src/modules/designConditions/calculations.js\r\n\r\n// Design-speed-based capacity (per lane, veh/h or pcu/h) – you can tune these.\r\nexport const SPEED_CAPACITY_TABLE = {\r\n  80: 2000,\r\n  100: 2200,\r\n  120: 2300\r\n};\r\n\r\n// Service level code mapping A-F -> 1-6\r\nconst SERVICE_LEVEL_MAP = { A: 1, B: 2, C: 3, D: 4, E: 5, F: 6 };\r\n\r\nexport function serviceLevelCodeToNumber(code) {\r\n  return SERVICE_LEVEL_MAP[code] || null;\r\n}\r\n\r\n/**\r\n * Compute basic stats for one direction from its segments.\r\n * segments: array of { slopePercent, lengthM, avgElevationM, laneCount }\r\n */\r\nexport function computeDirectionStats(segments) {\r\n  const totalLengthM = segments.reduce(\r\n    (sum, seg) => sum + (Number(seg.lengthM) || 0),\r\n    0\r\n  );\r\n\r\n  // Max lanes among segments in that direction\r\n  const lanes =\r\n    segments.reduce(\r\n      (max, seg) => Math.max(max, Number(seg.laneCount) || 0),\r\n      0\r\n    ) || 0;\r\n\r\n  return { totalLengthM, lanes };\r\n}\r\n\r\n/**\r\n * Estimate traffic volume for one direction.\r\n *\r\n * designSpeedKmH: 80 / 100 / 120 ...\r\n * capacityUsageRatio: 0.3 / 0.2 / 0.1 ...\r\n * lanes: number of lanes in this direction\r\n *\r\n * Returns { baseCapacityPerLane, capacityTotal, estimatedVolume }.\r\n */\r\nexport function estimateTrafficVolume({\r\n  designSpeedKmH,\r\n  capacityUsageRatio,\r\n  lanes\r\n}) {\r\n  const speed = Number(designSpeedKmH);\r\n  const ratio = Number(capacityUsageRatio);\r\n\r\n  const baseCapacityPerLane =\r\n    SPEED_CAPACITY_TABLE[speed] ?? SPEED_CAPACITY_TABLE[80];\r\n\r\n  const capacityTotal = baseCapacityPerLane * (lanes || 0);\r\n\r\n  const estimatedVolume = Math.round(capacityTotal * (ratio || 0));\r\n\r\n  return { baseCapacityPerLane, capacityTotal, estimatedVolume };\r\n}\r\n"],"mappings":"AAAA;;AAEA;AACA,OAAO,MAAMA,oBAAoB,GAAG;EAClC,EAAE,EAAE,IAAI;EACR,GAAG,EAAE,IAAI;EACT,GAAG,EAAE;AACP,CAAC;;AAED;AACA,MAAMC,iBAAiB,GAAG;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC;AAEhE,OAAO,SAASC,wBAAwBA,CAACC,IAAI,EAAE;EAC7C,OAAOR,iBAAiB,CAACQ,IAAI,CAAC,IAAI,IAAI;AACxC;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAACC,QAAQ,EAAE;EAC9C,MAAMC,YAAY,GAAGD,QAAQ,CAACE,MAAM,CAClC,CAACC,GAAG,EAAEC,GAAG,KAAKD,GAAG,IAAIE,MAAM,CAACD,GAAG,CAACE,OAAO,CAAC,IAAI,CAAC,CAAC,EAC9C,CACF,CAAC;;EAED;EACA,MAAMC,KAAK,GACTP,QAAQ,CAACE,MAAM,CACb,CAACM,GAAG,EAAEJ,GAAG,KAAKK,IAAI,CAACD,GAAG,CAACA,GAAG,EAAEH,MAAM,CAACD,GAAG,CAACM,SAAS,CAAC,IAAI,CAAC,CAAC,EACvD,CACF,CAAC,IAAI,CAAC;EAER,OAAO;IAAET,YAAY;IAAEM;EAAM,CAAC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,qBAAqBA,CAAC;EACpCC,cAAc;EACdC,kBAAkB;EAClBN;AACF,CAAC,EAAE;EAAA,IAAAO,qBAAA;EACD,MAAMC,KAAK,GAAGV,MAAM,CAACO,cAAc,CAAC;EACpC,MAAMI,KAAK,GAAGX,MAAM,CAACQ,kBAAkB,CAAC;EAExC,MAAMI,mBAAmB,IAAAH,qBAAA,GACvBzB,oBAAoB,CAAC0B,KAAK,CAAC,cAAAD,qBAAA,cAAAA,qBAAA,GAAIzB,oBAAoB,CAAC,EAAE,CAAC;EAEzD,MAAM6B,aAAa,GAAGD,mBAAmB,IAAIV,KAAK,IAAI,CAAC,CAAC;EAExD,MAAMY,eAAe,GAAGV,IAAI,CAACW,KAAK,CAACF,aAAa,IAAIF,KAAK,IAAI,CAAC,CAAC,CAAC;EAEhE,OAAO;IAAEC,mBAAmB;IAAEC,aAAa;IAAEC;EAAgB,CAAC;AAChE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}